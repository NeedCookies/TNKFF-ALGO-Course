# **Базовые структуры данных**
## Задача. Минимум на стеке
Имя входного файла: стандартный ввод  
Имя выходного файла: стандартный вывод  
Ограничение по времени: 1 секунда  
Ограничение по памяти: 256 мегабайт  

Вам требуется реализовать структуру данных, выполняющую следующие операции:
1. Добавить элемент x в конец структуры.
2. Удалить последний элемент из структуры.
3. Выдать минимальный элемент в структуре.  

#### **Формат входных данных**
В первой строке входного файла задано одно целое число n — количество операций (1 <= n <= 10^6).  
В следующих n строках заданы сами операции. В i-й строке число ti — тип операции (1, если операция добавления, 2, если операция удаления, 3, если операция минимума). Если задана операция добавления, то через пробел записано целое число x — элемент, который следует добавить в структуру (−10^9 <= x <= 10^9). Гарантируется, что перед каждой операцией удаления или нахождения
минимума структура не пуста. 
#### **Формат выходных данных**
Для каждой операции нахождения минимума выведите одно число — минимальный элемент в структуре. Ответы разделяйте переводом строки.
### Пример
| Стандартный ввод
|:----------------:|
```
8
1 2
1 3
1 -3
3
2
3
2
3
```
| Стандартный вывод |
|:----------------:|
```
-3
2
2
```
[Решение](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/BaseStructures/Task1/Task1/Program.cs)

## Задача. Минимум на отрезке
Имя входного файла: стандартный ввод  
Имя выходного файла: стандартный вывод  
Ограничение по времени: 0.5 секунд  
Ограничение по памяти: 256 мегабайт  
Рассмотрим последовательность целых чисел длины N. По ней с шагом 1 двигается «окно» длины K, то есть сначала в «окне» видно первые K чисел, на следующем шаге в «окне» уже будут находиться K чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения «окна» определить минимум в нём.
#### **Формат входных данных**
В первой строке входных данных содержатся два числа N и K (1 <= N <= 150000, 1 <= K <= 100000, K <= N) – длины последовательности и «окна», соответственно. На следующей строке находятся N чисел – сама последовательность. Числа последовательности не превосходят по модулю 10^5.
#### **Формат выходных данных**
Выходые данные должны содержать N − K + 1 строк – минимумы для каждого положения
«окна».
### Пример
| Стандартный ввод
|:----------------:|
```
7 3
1 3 2 4 5 3 1
```
| Стандартный вывод |
|:----------------:|
```
1 2 2 3 1
```
[Решение C#](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/BaseStructures/Task2/Task2/Program.cs)  
[Решение C++ (укладывается по времени)](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/BaseStructures/Task2/Task2C%2B%2B/Task2C%2B%2B/Task2C%2B%2B.cpp)

## Задача. Постфиксная запись
Имя входного файла: стандартный ввод  
Имя выходного файла: стандартный вывод  
Ограничение по времени: 1 секунда  
Ограничение по памяти: 256 мегабайт  

В постфиксной записи (или обратной польской записи) операция записывается после двух операндов. Например, сумма двух чисел A и B записывается как A B +. Запись B C + D ∗ обозначает привычное нам (B + C) ∗ D, а запись A B C + D ∗ + означает A + (B + C) ∗ D. Достоинство постфиксной записи в том, что она не требует скобок и дополнительных соглашений о приоритете операторов для своего чтения.
#### **Формат входных данных**
В единственной строке записано выражение в постфиксной записи, содержащее цифры и операции +, −, ∗. Числа и операции разделяются пробелами. В конце строки может быть произвольное количество пробелов. Числа не превосходят 100 по модулю.
#### **Формат выходных данных**
Необходимо вывести значение записанного выражения.
### Пример
| Стандартный ввод
|:----------------:|
```
8 9 + 1 7 - *
```
| Стандартный вывод |
|:----------------:|
```
-102
```
[Решение](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/BaseStructures/Task3/Task3/Program.cs)

## Задача. Шарики
Имя входного файла: стандартный ввод  
Имя выходного файла: стандартный вывод  
Ограничение по времени: 1 секунда  
Ограничение по памяти: 256 мегабайт  

В одной компьютерной игре игрок выставляет в линию шарики разных цветов. Когда образуется непрерывная цепочка из трех и более шариков одного цвета, она удаляется из линии. Все шарики при этом сдвигаются друг к другу, и ситуация может повториться.  
Напишите программу, которая по данной ситуации определяет, сколько шариков будет сейчас уничтожено. Естественно, непрерывных цепочек из трех и более одноцветных шаров в начальный момент может быть не более одной.
#### **Формат входных данных**
Дано количество шариков в цепочке (не более 10^5) и цвета шариков (от 0 до 9, каждому цвету соответствует свое целое число).
#### **Формат выходных данных**
Требуется вывести количество шариков, которое будет уничтожено.
### Примеры
| Стандартный ввод
|:----------------:|
```
5
1 3 3 3 2
------------------
10
3 3 2 1 1 1 2 2 3 3
```
| Стандартный вывод |
|:----------------:|
```
3
------------------
10
```
[Решение](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/BaseStructures/Task4/Task4/Program.cs)

## Задача. Сортировка вагонов
Имя входного файла: стандартный ввод  
Имя выходного файла: стандартный вывод  
Ограничение по времени: 1 секунда  
Ограничение по памяти: 256 мегабайт  

К тупику со стороны пути 1 (см. рисунок) подъехал поезд. Разрешается отцепить от поезда один или сразу несколько первых вагонов и завезти их в тупик (при желании, можно даже завезти в тупик сразу весь поезд). После этого часть из этих вагонов вывезти в сторону пути 2. После этого можно завезти в тупик еще несколько вагонов и снова часть оказавшихся вагонов вывезти в сторону пути 2. И так далее (так, что каждый вагон может лишь один раз заехать с пути 1 в тупик, а затем один раз выехать из тупика на путь 2). Заезжать в тупик с пути 2 или выезжать из тупика на путь 1 запрещается. Нельзя с пути 1 попасть на путь 2, не заезжая в тупик.  
Известно, в каком порядке изначально идут вагоны поезда. Требуется с помощью указанных операций сделать так, чтобы вагоны поезда шли по порядку (сначала первый, потом второй и т.д., считая от головы поезда, едущего по пути 2 в сторону от тупика).
#### **Формат входных данных**
Вводится число N — количество вагонов в поезде (1 <= N <= 2000). Дальше идут номера вагонов в порядке от головы поезда, едущего по пути 1 в сторону тупика. Вагоны пронумерованы натуральными числами от 1 до N, каждое из которых встречается ровно один раз.
#### **Формат выходных данных**
Если сделать так, чтобы вагоны шли в порядке от 1 до N, считая от головы поезда, когда поезд поедет по пути 2 из тупика, можно, выведите действия, которые нужно проделать с поездом. В первой строке выведите количество действий, а затем сами действия. Каждое из них описывается двумя числами: типом и количеством вагонов: 
* если нужно завезти с пути 1 в тупик K вагонов, должно быть выведено сначала число 1, а затем — число K (K > 1),  
* если нужно вывезти из тупика на путь 2 K вагонов, должно быть выведено сначала число 2, а затем — число K (K > 1).  

Если возможно несколько последовательностей действий, приводящих к нужному результату, выведите любую из них.  
Если выстроить вагоны по порядку невозможно, выведите одно число 0.
### Примеры
| Стандартный ввод
|:----------------:|
```
3
3 2 1
--------------
4
4 1 3 2
```
| Стандартный вывод |
|:----------------:|
```
2
1 3
2 3
--------------
4
1 2
2 1
1 2
2 3
```
[Решение](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/BaseStructures/Task5/Task5/Program.cs)

## Задача. Астроград
Имя входного файла: стандартный ввод  
Имя выходного файла: стандартный вывод  
Ограничение по времени: 1 секунда  
Ограничение по памяти: 256 мегабайт  
В Астрополисе прошел концерт популярной группы Астроград. За пару дней до концерта перед кассой выстроилась огромная очередь из людей, желающих туда попасть. Изначально очередь была пуста. В каждый из n моментов времени происходило следующее:  
1. В очередь пришел новый человек с уникальным номером id, он встает в очередь последним.
2. Человеку, стоящему спереди в очереди, удалось купить билет. Он уходит.
3. Человеку, стоящему последнему в очереди, надоело ждать. Он уходит.
4. Человек с уникальным номером q хочет знать, сколько людей стоит в очереди спереди него.
5. Очередь хочет знать, человек с каким уникальным номером стоит сейчас первым и задерживает всех.  

Вам необходимо написать программу, которая умеет обрабатывать описанные события.
#### **Формат входных данных**
В первой строке дано целое число n (1 <= n <= 10^6) — количество событий. В каждой из следующих n строк дано описание событий: номер события, а также число id (1 <= id <= 10^5) для событий типа 1 и число q для событий типа 4. События происходили в том порядке, в каком они описаны во входном файле. Гарантируется корректность всех событий.
#### **Формат выходных данных**
Выведите ответы для событий типа 4 и 5 в том порядке, в каком они описаны во входном файле.
### Пример
| Стандартный ввод
|:----------------:|
```
7
1 1
5
1 3
3
2
1 2
4 2
```
| Стандартный вывод |
|:----------------:|
```
1
0
```
[Решение C#](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/BaseStructures/Task6/Task6/Program.cs)  
[Решение C++ (Проходит по времени)](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/BaseStructures/Task6C%2B%2B/Task6C%2B%2B/Task6C%2B%2B.cpp)

## Задача G. Гоблины и очереди
Имя входного файла: стандартный ввод  
Имя выходного файла: стандартный вывод  
Ограничение по времени: 0.6 секунд  
Ограничение по памяти: 256 мегабайт  

Гоблины Мглистых гор очень любях ходить к своим шаманам. Так как гоблинов много, к шаманам часто образуются очень длинные очереди. А поскольку много гоблинов в одном месте быстро образуют шумную толку, которая мешает шаманам проводить сложные медицинские манипуляции, последние решили установить некоторые правила касательно порядка в очереди.  
Обычные гоблины при посещении шаманов должны вставать в конец очереди. Привилегированные же гоблины, знающие особый пароль, встают ровно в ее середину, причем при нечетной длине очереди они встают сразу за центром.  
Так как гоблины также широко известны своим непочтительным отношением ко всяческим правилам и законам, шаманы попросили вас написать программу, которая бы отслеживала порядок
гоблинов в очереди.
#### **Формат входных данных**
В первой строке входных данный записано число N (1 <= N <= 10^5) − количество запросов.  
Следующие N строк содержат описание запросов в формате:
* \+ i − гоблин с номером i (1 6 i 6 N) встаёт в конец очереди.
* \* i − привилегированный гоблин с номером i встает в середину очереди.
* \- − первый гоблин из очереди уходит к шаманам. Гарантируется, что на момент такого запроса очередь не пуста.  
#### **Формат выходных данных**
Для каждого запроса типа - программа должна вывести номер гоблина, который должен зайти к шаманам.
### Примеры
| Стандартный ввод
|:----------------:|
```
7
+ 1
+ 2
-
+ 3
+ 4
-
-
------------------
2
* 1
+ 2
```
| Стандартный вывод |
|:----------------:|
```
1
2
3
-------------

```
[Решение](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/BaseStructures/Task7/Task7/Program.cs)

## Задача. Хорошие дни
Имя входного файла: стандартный ввод  
Имя выходного файла: стандартный вывод  
Ограничение по времени: 0.25 секунд  
Ограничение по памяти: 256 мегабайт  

Вам дан массив целых неотрицательных чисел. Вы хотите найти в нем такой подотрезок (последовательность подряд идущих элементов), что в нем максимально возможная сумма, помноженная на минимум.  
Поиск такого подотрезка является достаточно сложной задачей, поэтому мы приведем разбивку алгоритма по шагам. Не волнуйтесь, вам найдется, над чем подумать.  
Итак, для начала требуется решить вспомогательную задачу — для каждого элемента массива найти ближайший слева элемент, меньший данного. То есть, посчитать previ = j, такой что j < i, aj < ai, aj+1 > ai, aj+2 > ai, . . . ai > ai.  
Дальше, воспользовавшись таким алгоритмом, можно для каждого элемента i найти такой отрезок самой большой длины, что i является минимумом на всем этом отрезке. Ответом на задачу будет один из этих отрезков.  
Для поиска суммы на отрезке можно воспользоваться, например, префиксными суммами.  
Сделать поиск ближайшего элемента слева, меньше данного, можно сделать за один линейный проход со стеком — нужно только догадаться, что хранить в стеке, когда делать добавления, а когда
удаления.
#### **Формат входных данных**
Первая строка входного файла содержит число n — количество элементов массива
(1 <= n <= 100 000).  
Оставшаяся часть файла содержит n целых чисел a1, a2, . . . , an, все в пределах от 0 до 10^6. Числа во входном файле разделяются пробелами и переводами строки.
#### **Формат выходных данных**
В первой строке выходного файла выведите максимальную величину «сумма подотрезка, помноженная на минимум в этом подотрезке»
### Примеры
| Стандартный ввод
|:----------------:|
```
6
3 1 6 4 5 2
--------------------
4
1 2 1 2
--------------------
3
2 1 2
--------------------
3
2 2 1
```
| Стандартный вывод |
|:----------------:|
```
60
--------------------
6
--------------------
5
--------------------
8
```
[Решение C#](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/BaseStructures/Task8/Task8/Program.cs)  
[Решение C++ (проходит по времени)](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/BaseStructures/Task8C%2B%2B/Task8C%2B%2B/Task8C%2B%2B.cpp)