# Деревья
## Задача. Примитивы
Имя входного файла: стандартный ввод  
Имя выходного файла: стандартный вывод  
Ограничение по времени: 1 секунда  
Ограничение по памяти: 256 мегабайт  

Дано дерево с корнем в вершине 0 (необязательно двоичное). Посчитайте:
1. Высоту дерева – максимальное расстояние от корня до листа.
2. Диаметр дерева – максимальная длина пути между двумя вершинами (естественно, путь не
должен проходить через одну вершину несколько раз).
3. Для каждой вершины найдите её глубину – длину пути от корня до вершины.

#### **Формат входных данных**
В первой строке вводится натуральное число n – размер дерева (2 6 n 6 105
). В следующей строке записано n − 1 целое число pi — предок вершины i (0 6 pi < i).
#### **Формат выходных данных**
Выведете две строки. В первой строке выведите два числа: высоту и диаметр дерева. Во второй строке для каждой вершины выведите её глубину.
### Примеры
| Стандартный ввод
|:----------------:|
```
7
0 0 1 1 1 2
-----------------
6
0 1 2 2 2
```
| Стандартный вывод |
|:----------------:|
```
2 4
0 1 1 2 2 2 2
-----------------
3 3
0 1 2 3 3 3
```
[Решение](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/Trees/Task1/Task1/Program.cs)  

## Задача. AVL?
Имя входного файла: стандартный ввод  
Имя выходного файла: стандартный вывод  
Ограничение по времени: 1 секунда  
Ограничение по памяти: 256 мегабайт  

Дано двоичное дерево с корнем в вершине r. Проверьте, является ли оно корректным AVLдеревом.  
Напоминание: AVL-дерево – это дерево, для которого выполняются следующие условия:
1. оба поддерева – левое и правое – являются AVL-деревьями;
2. все вершины левого поддерева вершины X, меньше самой вершины X;
3. все вершины правого поддерева вершины X, больше самой вершины X;
4. для каждой вершины высота её двух поддеревьев различается не более чем на 1 (высота – расстояние до самого дальнего листа).
#### **Формат входных данных**
В первой строке вводится натуральное число n – размер дерева (1 <= n <= 10^5) и r – корень дерева (0 <= r < n).  
В следующих n строках записаны два числа li, ri – левый и правый ребенок i-й вершины (−1 <= li, ri < n; li, ri = −1, если у вершины нет соответствующего ребенка).  
Гарантируется, что задано корректное двоичное дерево.
#### **Формат выходных данных**
Выведите одно число: 0, если дерево заданное дерево не является AVL-деревом и 1 иначе
### Примеры
| Стандартный ввод
|:----------------:|
```
6 3
-1 -1
0 2
-1 -1
1 4
-1 5
-1 -1
---------------
6 3
-1 -1
0 2
-1 -1
1 4
5 -1
-1 -1
```
| Стандартный вывод |
|:----------------:|
```
1
---------------
0
```
[Решение](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/Trees/Task2/Task2/Program.cs)  

## Задача. LCA
Имя входного файла: стандартный ввод  
Имя выходного файла: стандартный вывод  
Ограничение по времени: 1 секунда  
Ограничение по памяти: 256 мегабайт  

Дано подвешенное дерево с корнем в вершине 0. Вам нужно ответить на m запросов вида «найти LCA двух вершин». LCA вершин u и v в подвешенном дереве – это наиболее удаленная от корня дерева вершина, лежащая на обоих путях от u и v до корня.
#### **Формат входных данных**
В первой строке вводится натуральное число n – размер дерева (2 6 n 6 103
). В следующей строке записано n − 1 целое число pi — предок вершины i (0 6 pi < i).  
Затем дано число m. Далее заданы m (0 < m <= 10^3) запросов вида (u, v) – найти LCA двух вершин u и v (0 6 u, v < n; u 6= v).
#### **Формат выходных данных**
На каждый из m запросов выведите по одному числу – LCA заданных вершин.
### Примеры
| Стандартный ввод
|:----------------:|
```
5
0 0 1 2
2
1 2
3 4
-------------------
5
0 0 1 1
3
3 4
3 1
2 4
```
| Стандартный вывод |
|:----------------:|
```
0
0
-------------------
1
1
0
```
[Решение](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/Trees/Task3/Task3/Program.cs)  

## Задача. Хипуй!
Имя входного файла: стандартный ввод  
Имя выходного файла: стандартный вывод  
Ограничение по времени: 1 секунда  
Ограничение по памяти: 256 мегабайт  

В этой задаче вам необходимо организовать структуру данных Heap для хранения целых чисел, над которой определены следующие операции:
1. Insert(X) — добавить в Heap число X;
2. Extract — достать из Heap наибольшее число (удалив его при этом).  
   
Эту задачу нужно решить без использования встроенных структур данных для поиска максимального числа.
#### **Формат входных данных**
Во входном файле записано количество команд n (1 <= n <= 100000), потом последовательность из n команд, каждая в своей строке.  
Каждая команда имеет такой формат: «0 число» или «1», что означает соответственно операции «Insert(число)» и «Extract». Добавляемые числа находятся в интервале от 1 до 107 включительно.  
Гарантируется, что при выполнении команды Extract в структуре находится по крайней мере один элемент.
#### **Формат выходных данных**
В выходной файл для каждой команды извлечения необходимо вывести число, полученное при выполнении команды «Extract».
### Пример
| Стандартный ввод
|:----------------:|
```
7
0 100
0 10
1
0 5
0 30
0 50
1
```
| Стандартный вывод |
|:----------------:|
```
100
50
```
[Решение](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/Trees/Task4/Task4/Program.cs) 

## Задачa. Хипуй! Сортируй!
Имя входного файла: стандартный ввод  
Имя выходного файла: стандартный вывод  
Ограничение по времени: 1 секунда  
Ограничение по памяти: 256 мегабайт  

В этой задаче вам необходимо организовать структуру данных Heap для хранения целых чисел и с её помощью отсортировать заданный массив.  
Эту задачу нужно решить без использования встроенных алгоритмов/структур данных для сортировок.
#### **Формат входных данных**
В первой строке входного файла задано одно натуральное число n (1 <= n <= 100000). Во второй строке задан массив a размера n, где −10^9 <= ai <= 10^9.
#### **Формат выходных данных**
В выходной файл необходимо вывести отсортированный массив a.
### Примеры
| Стандартный ввод
|:----------------:|
```
10
1 8 2 1 4 7 3 2 3 6
```
| Стандартный вывод |
|:----------------:|
```
1 1 2 2 3 3 4 6 7 8
```
[Решение](https://github.com/NeedCookies/TNKFF-ALGO-Course/blob/main/Trees/Task5/Task5/Program.cs) 